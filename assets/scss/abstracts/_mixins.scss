// - - - - - - - - - - - - - - - - - - - - - - - - -
// Mixins
// - - - - - - - - - - - - - - - - - - - - - - - - -

// Visually Shown
// Will show the visually hidden element
// ------------------
@mixin visually-show($z-index) {
	opacity: 1;
	visibility: visible;
	z-index: $z-index;
}

// Visually Hidden
// Visually Hidden so that it can have transisitions applyed to it.
// ------------------
@mixin visually-hidden($z-index) {
	opacity: 0;
	visibility: hidden;
	z-index: $z-index;
}

// Unstyled list
// Removes all basic list styling
// ------------------
@mixin unstyled-list {
  list-style: none;
  margin: 0;
  padding: 0;
}

// Background Image
// Includes a number of repeatable background-image items
// ------------------
@mixin background-img {
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center;
}

// Placeholder Mixin
// because no one wants to put placeholder in as non prefixed yet
// ------------------
@mixin placeholder {
  &::-webkit-input-placeholder {
    @content;
  }

  &:-moz-placeholder { /* Firefox 18- */
    @content;
  }

  &::-moz-placeholder {  /* Firefox 19+ */
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

// Clearfix
// The clearfix is augmented with specific styles to prevent borders in flexbox environments
// @link http://nicolasgallagher.com/micro-clearfix-hack/ Micro Clearfix Hack
// @link http://danisadesigner.com/blog/flexbox-clear-fix-pseudo-elements/ Flexbox fix
// ------------------
@mixin clearfix {
	&::after,
	&::before {
		content: ' ';
		display: table;
		flex-basis: 0;
		order: 1;
	}

	&::after {
		clear: both;
	}
}

/// Removes the focus ring around an element when a mouse input is detected.
// ------------------
@mixin disable-mouse-outline {
	[data-whatinput='mouse'] & {
		outline: 0;
	}
}

// Makes an element visually hidden, but still accessible to keyboards and assistive devices.
// ------------------
@mixin element-invisible {
	position: absolute !important;
	width: 1px;
	height: 1px;
	overflow: hidden;
	clip: rect(1px, 1px, 1px, 1px);
  white-space: nowrap;
}

// Reverses the CSS output created by the `element-invisible()` mixin.
// ------------------
@mixin element-invisible-off {
	position: static !important;
	height: auto;
	width: auto;
	overflow: visible;
	clip: auto;
  white-space: nowrap;
}

// Vertically centers the element inside of its first non-static parent,
// @link http://www.sitepoint.com/centering-with-sass/ Centering With Sass
// ------------------
@mixin vertical-center {
	position: absolute;
	top: 50%;
	transform: translateY(-50%);
}

// Horizontally centers the element inside of its first non-static parent,
// @link http://www.sitepoint.com/centering-with-sass/ Centering With Sass
// ------------------
@mixin horizontal-center {
	position: absolute;
	left: 50%;
	transform: translateX(-50%);
}

// Absolutely centers the element inside of its first non-static parent,
// @link http://www.sitepoint.com/centering-with-sass/ Centering With Sass
// ------------------
@mixin absolute-center {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	-webkit-transform: translate(-50%, -50%); // for some reason, this does not seem to be outputted out by autoprefixer.
}

// Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes.
// @param {Boolean} $small [true] - If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up.
@mixin -zf-each-breakpoint($small: true) {
	$map: $breakpoint-classes;
	@if not $small {
		$map: map-remove($map, small);
	}
	@each $size in $map {
		$-zf-size: $size !global;
		@include breakpoint($size) {
			 @content;
		}
	}
}
